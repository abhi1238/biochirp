<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>BioChirp - Biological Research AI (Chat)</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/common.min.js"></script>

<style>
  :root[data-theme="dark"]{
    --bg0:#070A15; --bg1:#0B1222; --bg2:#0E1626; --bg3:#121C2E;
    --card:#0F1828; --txt:#EAF2FF; --mut:#9FB0C4;
    --brd:rgba(255,255,255,.10); --hover:rgba(255,255,255,.06);
    --accent:#1FA4FF; --accent2:#A78BFA; --ok:#00E38C; --err:#ff6b6b;
    --shadow:0 18px 55px rgba(0,0,0,.45);
  }
  :root[data-theme="light"]{
    --bg0:#F6FAFF; --bg1:#FFFFFF; --bg2:#FFFFFF; --bg3:#F4F7FB;
    --card:#FFFFFF; --txt:#0B1624; --mut:#486173;
    --brd:rgba(0,0,0,.10); --hover:rgba(0,0,0,.04);
    --accent:#1FA4FF; --accent2:#6D50FF; --ok:#0FB27A; --err:#E25050;
    --shadow:0 18px 55px rgba(17,24,39,.14);
  }
  :root{ --chat-max: 1200px; }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    min-height:100vh; color:var(--txt); background:var(--bg0);
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column;
    background:
      radial-gradient(900px 600px at -20% -10%, rgba(31,164,255,.10) 0%, transparent 60%),
      radial-gradient(900px 600px at 110% 110%, rgba(167,139,250,.10) 0%, transparent 55%),
      linear-gradient(135deg,var(--bg0) 0%,var(--bg1) 100%);
  }

  .app{display:flex; min-height:100vh;}
  .chat{flex:1; display:flex; flex-direction:column; min-width:0;}

  .chat-header{
    position:sticky; top:0; z-index:5; padding:10px 16px;
    border-bottom:1px solid var(--brd);
    display:flex; align-items:center; justify-content:space-between;
    background:color-mix(in oklab, var(--bg1) 86%, transparent);
    backdrop-filter: blur(10px) saturate(1.25);
  }
  .leftHdr{display:flex; align-items:center; gap:10px}
  .chat-title{font-size:18px; font-weight:800; letter-spacing:.01em}
  .chat-title small{font-weight:700; color:var(--mut); font-size:12px}
  .status-wrap{display:flex; gap:8px; align-items:center}
  .connection-status{
    display:flex; gap:8px; align-items:center; padding:6px 10px;
    border-radius:999px; border:1px solid var(--brd);
    background:var(--bg2); font-size:12px
  }
  .status-dot{width:9px;height:9px;border-radius:50%;background:var(--ok)}
  .reconnect,.theme-btn{
    padding:6px 10px;border-radius:10px;border:1px solid var(--brd);
    background:var(--bg2);color:var(--txt);cursor:pointer;font-size:12px;
    display:inline-flex;align-items:center;gap:6px;
    transition:background .15s ease, transform .06s ease, border-color .15s ease;
  }
  .reconnect:hover,.theme-btn:hover{
    background:var(--hover); border-color:color-mix(in oklab,var(--accent) 30%,var(--brd));
  }
  .reconnect:active,.theme-btn:active{ transform:translateY(1px) }

  .quick-asks{
    max-width: var(--chat-max);
    margin: 10px auto 0;
    padding: 0 16px;
    display:grid;
    grid-template-columns: repeat(4, minmax(0,1fr));
    gap:10px;
  }
  .qa-card{
    border:1px solid var(--brd);
    background:radial-gradient(circle at top left, rgba(31,164,255,.12), transparent 55%), var(--card);
    color:var(--txt);
    padding:12px 14px;
    border-radius:14px;
    font-size:13px;
    cursor:pointer;
    box-shadow: var(--shadow);
    transition: transform .06s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
    user-select:none;
  }
  .qa-card:hover{
    background:radial-gradient(circle at bottom right, rgba(167,139,250,.18), transparent 55%), var(--bg2);
    border-color: color-mix(in oklab, var(--accent) 35%, var(--brd));
    box-shadow: 0 16px 45px rgba(0,0,0,.38);
  }
  .qa-card:active{ transform: translateY(1px) scale(.99); }

  .messages{
    flex:1; overflow-y:auto; padding:16px;
    display:flex; flex-direction:column; gap:14px;
  }
  .message{display:flex; gap:12px; max-width:var(--chat-max); margin-inline:auto;}
  .message.user{align-self:flex-end; flex-direction:row-reverse; margin-left:auto; margin-right:0;}
  .message-avatar{
    width:36px;height:36px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    background:#fff;color:#0b1222;border:1px solid var(--brd);
    font-size:18px;
    box-shadow:0 4px 16px rgba(0,0,0,.25);
  }
  .message-avatar img{
    width:100%; height:100%; border-radius:12px;
    display:block; background:transparent;
  }
  .message-content{flex:1; display:flex; flex-direction:column; gap:8px; min-width:0}
  .timestamp{font-size:11px; color:var(--mut)}
  .message-bubble{
    position:relative; padding:12px 14px; border-radius:16px;
    background:var(--card); border:1px solid var(--brd);
    line-height:1.6; font-size:15px; overflow-wrap:anywhere;
    box-shadow:var(--shadow);
  }
  .message.user .message-bubble{
    background:linear-gradient(135deg,rgba(31,164,255,.15),rgba(167,139,250,.18)), var(--card);
    border-color:color-mix(in oklab,var(--accent) 55%, var(--brd));
  }
  .message.assistant .message-bubble pre{
    background:var(--bg3);border:1px solid var(--brd);
    border-radius:12px;padding:12px;overflow:auto
  }
  .message.assistant .message-bubble code{
    background:var(--bg3);border:1px solid var(--brd);
    padding:2px 6px;border-radius:6px
  }

  .tool-card{background:var(--card);border:1px solid var(--brd);border-radius:12px;overflow:hidden;margin-top:6px}
  .tool-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;cursor:pointer}
  .tool-info{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .tool-icon{
    width:22px;height:22px;border-radius:6px;
    display:flex;align-items:center;justify-content:center;
    background:#fff;color:#0b1222;border:1px solid var(--brd);font-size:12px
  }
  .tool-name{font-weight:800;font-size:13px}
  .tool-chips{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  .chip{font-size:11px;padding:3px 8px;border-radius:10px;font-weight:700;border:1px solid var(--brd);background:var(--bg2);color:var(--mut)}
  .chip.status.running{color:#ffd76a}
  .chip.status.completed{color:#63ffb3}
  .chip.status.failed{color:#ff9c9c}
  .chip.time{color:var(--txt)}
  .expand-icon{transition:.25s;color:var(--mut)}
  .tool-card.expanded .expand-icon{transform:rotate(180deg)}
  .tool-body{max-height:0;overflow:hidden;transition:max-height .3s}
  .tool-card.expanded .tool-body,
  .tool-card.show-output .tool-body{max-height:70vh;overflow:auto}
  .tool-output{padding:12px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:14px;white-space:pre-wrap;word-break:break-word}

  .table-toolbar{
    display:flex; align-items:center; justify-content:space-between;
    gap:8px; margin:2px 0 8px;
  }
  .table-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .pager{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--mut); flex-wrap:wrap; }
  .pager button{
    padding:6px 10px; border-radius:10px; border:1px solid var(--brd);
    background:var(--bg2); color:var(--txt); cursor:pointer; font-size:12px;
  }
  .pager button:disabled{ opacity:.5; cursor:not-allowed; }

  .input-area{
    padding:12px 14px;border-top:1px solid var(--brd);
    background:color-mix(in oklab, var(--bg1) 92%, transparent);
    backdrop-filter: blur(10px) saturate(1.2);
  }
  .input-container{display:flex;gap:10px;align-items:flex-end; max-width:var(--chat-max); margin:0 auto}
  .input-wrapper{flex:1}
  #messageInput{
    width:100%;min-height:48px;max-height:150px;padding:12px 14px;
    border-radius:12px;outline:none;resize:none;
    background:var(--card);border:1px solid var(--brd);
    color:var(--txt);font-size:14px;
    box-shadow:var(--shadow);
  }
  #messageInput::placeholder{ color:color-mix(in oklab,var(--mut) 80%, transparent); }
  #sendButton{
    width:52px;height:52px;border:none;border-radius:14px;
    color:#00162a;cursor:pointer;font-size:20px;
    background:linear-gradient(135deg,var(--accent),var(--accent2));
    box-shadow:var(--shadow);
    display:flex;align-items:center;justify-content:center;
    transition:transform .06s ease, box-shadow .15s ease, opacity .15s ease;
  }
  #sendButton:disabled{ opacity:.45; cursor:not-allowed; }
  #sendButton:not(:disabled):active{ transform:translateY(1px) scale(.98); box-shadow:0 8px 24px rgba(0,0,0,.4); }

  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }

  @media (max-width: 920px){
    .message{max-width:100%}
    .quick-asks{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    .chat-header{flex-direction:column;align-items:flex-start;gap:8px}
    .status-wrap{align-self:stretch;justify-content:flex-start;flex-wrap:wrap}
  }

  /* For snapshot (kept harmless; no share UI) */
  details.tool-card {
    border-radius: 12px;
    border: 1px solid var(--brd);
    background: var(--card);
    overflow: hidden;
  }
  details.tool-card > summary.tool-header {
    list-style: none;
  }
  details.tool-card > summary.tool-header::-webkit-details-marker {
    display: none;
  }
  details.tool-card[open] .expand-icon {
    transform: rotate(180deg);
  }
  details.tool-card .tool-body {
    max-height: none !important;
    overflow: visible !important;
  }

    /* 1. Make sure tool content never exceeds the card width */
  .tool-output {
    max-width: 100%;
    overflow-x: auto;           /* if something is too wide, scroll inside the card */
    word-wrap: break-word;
  }

  /* 2. Wrap long lines inside tool markdown (lists, paragraphs, etc.) */
  .tool-output p,
  .tool-output li {
    word-break: break-word;
    overflow-wrap: anywhere;
  }

  /* 3. Optional: avoid pre blocks forcing the whole page to scroll horizontally */
  .tool-output pre {
    max-width: 100%;
    overflow-x: auto;           /* horizontal scroll only inside the code block */
  }

  /* (You can do the same for the main chat bubble if needed) */
  .message-bubble {
    max-width: 100%;
    overflow-wrap: anywhere;
  }

</style>
</head>
<body>
<div class="app">
  <main class="chat">
    <header class="chat-header">
      <div class="leftHdr">
        <div class="chat-title">
          Research Chat <small>‚Ä¢ Biological Intelligence</small>
        </div>
      </div>
      <div class="status-wrap">
        <button class="theme-btn" id="themeToggle">üåì Theme</button>
        <button class="reconnect" onclick="manualReconnect()">‚ü≥ Reconnect</button>
        <div class="connection-status">
          <div class="status-dot" id="statusDot"></div>
          <span id="connectionStatus">Connecting‚Ä¶</span>
        </div>
      </div>
    </header>

    <div id="quickAsks" class="quick-asks" aria-label="Quick questions">
      <div class="qa-card" onclick="askPreset('What are the drugs for TB?')">üíä What are the drugs for TB?</div>
      <div class="qa-card" onclick="askPreset('List the TKI.')">üéØ List the TKI</div>
      <div class="qa-card" onclick="askPreset('What are the genes linked to asthma?')">üß¨ Genes linked to asthma</div>
      <div class="qa-card" onclick="askPreset('What are the pathway and biomarker linked to melanoma?')">üß™ Pathways & biomarkers in melanoma</div>
    </div>

    <section class="messages" id="messagesContainer"></section>

    <footer class="input-area">
      <div class="input-container">
        <div class="input-wrapper">
          <textarea id="messageInput" placeholder="Ask about drugs, pathways, biomarkers, or clinical data..." rows="1"></textarea>
        </div>
        <button id="sendButton" title="Send" onclick="sendMessage()">‚û§</button>
      </div>
    </footer>
  </main>
</div>

<script>
  // const WS_URL = 'wss://biochirp.iiitd.edu.in/chat';
  const WS_URL = 'wss://biochirp.iiitd.edu.in/chat/';

  marked.setOptions({
    gfm:true, breaks:true, mangle:false, headerIds:false,
    highlight:(code,lang)=>{ try{return hljs.highlight(code,{language:lang}).value;}catch{return hljs.highlightAuto(code).value;} }
  });

  let ws=null, pingInterval=null;
  let currentAssistantMessage=null;
  let currentToolCards=new Map();
  let toolBuffers=new Map();
  let toolCount=0;

  const toolStartTimes = new Map();
  const toolElapsed = new Map();

  let orchestratorDone=false;
  let isStreaming=false;

  let orchestratorBuf='';
  let suppressOrchStream=false;

  let pendingUI = new Map();
  let rafScheduled = false;

  const primaryByName = new Map();   // name -> primary tool_id
  const aliasToPrimary = new Map();  // aliasId -> primaryId
  const nameKey = (n)=> String(n||'tool').trim().toLowerCase();
  const canonicalId = (raw)=> aliasToPrimary.get(raw) || raw || 'tool';

  const activeSessionId = 'sess_' + Math.random().toString(36).slice(2,10);

  function setStatus(t,ok){
    document.getElementById('connectionStatus').textContent=t;
    document.getElementById('statusDot').style.background=ok?'var(--ok)':'var(--err)';
  }
  function startPing(){
    clearInterval(pingInterval);
    pingInterval=setInterval(()=>{
      if(ws&&ws.readyState===WebSocket.OPEN){
        ws.send(JSON.stringify({type:'ping',ts:Date.now()}));
      }
    },30000);
  }
  function nowStamp(){ return new Date().toLocaleString(); }
  function scrollEnd(){
    const mc=document.getElementById('messagesContainer');
    mc.scrollTop=mc.scrollHeight;
  }
  function esc(s){
    const d=document.createElement('div');
    d.textContent=s==null?'':String(s);
    return d.innerHTML;
  }

  function disableInput(){
    document.getElementById('messageInput').disabled=true;
    document.getElementById('sendButton').disabled=true;
  }
  function enableInput(){
    document.getElementById('messageInput').disabled=false;
    document.getElementById('sendButton').disabled=false;
  }

  function startStreaming(){ isStreaming=true; }
  function maybeFinishStreaming(){
    if (orchestratorDone && toolCount===0) {
      isStreaming=false;
    }
  }

  function connect(){
    try{ ws && ws.close(); }catch{}
    disableInput();
    ws=new WebSocket(WS_URL);
    ws.onopen=()=>{
      setStatus('Connected',true);
      startPing();
      enableInput();
    };
    ws.onclose=()=>{
      setStatus('Disconnected',false);
      disableInput();
      setTimeout(connect,1500);
    };
    ws.onerror=()=>{
      setStatus('Error',false);
      disableInput();
    };
    ws.onmessage=(e)=>{
      let d;
      try{ d = JSON.parse(e.data); }catch{ return; }
      route(d);
    };
  }
  window.addEventListener('load', ()=>{
    resetChatUI();
    connect();
    initTheme();
  });
  function manualReconnect(){
    try{ if(ws) ws.close(); }catch{}
    connect();
  }

  function resetChatUI(){
    const mc=document.getElementById('messagesContainer');
    mc.innerHTML = `
      <div class="message assistant">
        <div class="message-avatar" title="Assistant">
          <img src="assets/brand/logo.svg" alt="Assistant">
        </div>
        <div class="message-content">
          <div class="timestamp">${nowStamp()}</div>
          <div class="message-bubble">Welcome to **BioChirp**! Ask about drugs, pathways, biomarkers, or clinical data.</div>
        </div>
      </div>`;
    currentAssistantMessage=null; currentToolCards.clear(); orchestratorBuf='';
    toolBuffers.clear(); toolCount=0; suppressOrchStream=false;
    orchestratorDone=false; isStreaming=false;
    toolStartTimes.clear(); toolElapsed.clear();
    const last = mc.querySelector('.message-bubble');
    if(last){
      last.innerHTML = marked.parse(last.textContent);
      last.querySelectorAll('pre code').forEach(c=>hljs.highlightElement(c));
    }
    scrollEnd();
    showQuickAsks();
  }

  function createAssistant(){
    const el=document.createElement('div'); el.className='message assistant';
    el.innerHTML=`<div class="message-avatar" title="Assistant">
        <img src="assets/brand/logo.svg" alt="Assistant">
      </div>
      <div class="message-content">
        <div class="timestamp">${nowStamp()}</div>
        <div class="message-bubble"></div>
      </div>`;
    document.getElementById('messagesContainer').appendChild(el);
    return el;
  }
  function mainBubble(msgDiv){
    const mc=msgDiv.querySelector('.message-content');
    let b=[...mc.querySelectorAll('.message-bubble')].find(x=>!x.closest('.tool-card'));
    if(!b){
      b=document.createElement('div');
      b.className='message-bubble';
      mc.appendChild(b);
    }
    return b;
  }
  function toolClass(n){
    n=(n||'').toLowerCase();
    if(n.includes('ttd')||n.includes('ctd')||n.includes('hcdt'))return'table-card';
    if(n.includes('web'))return'tool-web';
    if(n.includes('interpreter'))return'tool-interpreter';
    return'tool-generic';
  }
  function toolEmoji(n){
    n = String(n||'').toLowerCase();
    if (n.includes('ttd'))          return 'üéØ';
    if (n.includes('ctd'))          return 'üß™';
    if (n.includes('hcdt'))         return 'üíä';
    if (n.includes('web'))          return 'üåê';
    if (n.includes('interpreter'))  return 'üß†';
    if (n.includes('readme'))       return 'üìñ';
    if (n.includes('memory'))       return 'üóÇÔ∏è';
    if (n.includes('tavily') || n.includes('search')) return 'üîé';
    if (n.includes('orchestrator')) return 'ü§ñ';
    return 'üõ†Ô∏è';
  }
  function fmtMs(ms){
    if (ms < 1000) return Math.max(0, Math.round(ms)) + ' ms';
    const s = ms/1000;
    return (s<60) ? s.toFixed(2) + ' s' : (s/60).toFixed(2) + ' min';
  }

  function createToolCard(id,name){
    const c=document.createElement('div');
    c.className=`tool-card ${toolClass(name)}`; c.dataset.toolId=id;
    const icon = toolEmoji(name);
    c.innerHTML=`<div class="tool-header" onclick="toggleCard(this)">
        <div class="tool-info">
          <div class="tool-icon">${icon}</div>
          <div class="tool-name">${esc(name||'Tool')}</div>
          <div class="tool-chips">
            <div class="chip status running">Running‚Ä¶</div>
            <div class="chip time" data-timechip>Time: ‚Äî</div>
          </div>
        </div>
        <div class="expand-icon">‚ñæ</div>
      </div>
      <div class="tool-body">
        <div class="tool-output">Streaming‚Ä¶</div>
      </div>`;
    return c;
  }
  function toggleCard(h){
    const c = h.closest('.tool-card');
    c.classList.toggle('expanded');
    if (c.classList.contains('expanded')) c.dataset.userHold = '1';
  }
  function scheduleFlush(){
    if (rafScheduled) return;
    rafScheduled = true;
    requestAnimationFrame(() => {
      rafScheduled = false;
      for (const [id, chunk] of pendingUI.entries()) {
        pendingUI.delete(id);
        const card = currentToolCards.get(id);
        if (!card) continue;
        const outEl = card.querySelector('.tool-output');
        if (!outEl.dataset.streamed) { outEl.dataset.streamed = '1'; outEl.textContent = ''; }
        if (chunk) outEl.textContent += chunk;
        card.classList.add('expanded');
      }
      scrollEnd();
    });
  }

  function sanitizeOrchestrator(content){
    if (!content) return '';
    const t = content.trim();
    const startsWithEcho = /^\s*`{0,3}\s*"?input[_ ]?query"?\s*[:=>]/i.test(t);
    const shortEcho = t.length <= 500 && /input[_ ]?query/i.test(t) && !/\n.*\n.*\n/.test(t);
    const fencedEcho = /^```[\s\S]*?input[_ ]?query[\s\S]*?```$/i.test(t) && !/```[\s\S]*?```[\s\S]*?```/i.test(t);
    return (startsWithEcho || shortEcho || fencedEcho) ? '' : content;
  }

  function onOrchDelta(text){
    if (!text) return;
    const maybe = sanitizeOrchestrator(text);
    if (!maybe) return;

    orchestratorBuf += maybe;
    if (suppressOrchStream) return;

    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const bubble = mainBubble(currentAssistantMessage);
    bubble.innerHTML = marked.parse(orchestratorBuf) +
      `<span style="display:inline-block;width:2px;height:1em;background:var(--accent);margin-left:2px;animation:blink 1s infinite"></span>`;
    bubble.querySelectorAll('pre code').forEach(c => hljs.highlightElement(c));
    scrollEnd();
  }
  function onOrchFinal(text){
    const cleaned = sanitizeOrchestrator(text);
    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const bubble = mainBubble(currentAssistantMessage);
    bubble.innerHTML = marked.parse(cleaned || orchestratorBuf || '');
    bubble.querySelectorAll('pre code').forEach(c=>hljs.highlightElement(c));
    orchestratorBuf = '';
    orchestratorDone = true;
    maybeFinishStreaming();
    scrollEnd();
  }

  function route(d){
    switch(d.type){
      case 'heartbeat':
      case 'pong':
      case 'user_ack':
        return;

      case 'orchestrator_delta':
        onOrchDelta(d.content);
        return;

      case 'orchestrator_final':
        onOrchFinal(d.content);
        return;

      case 'delta': {
        const nm = String(d.name||'').toLowerCase();
        const isOrch = nm.includes('orchestrator') || (d.tool_id||'') === 'orchestrator';
        const chunk = d.text ?? d.delta ?? d.content ?? '';
        if (isOrch) {
          onOrchDelta(chunk);
          return;
        }
        const id = canonicalId(d.tool_id || 'tool');
        const t = String(chunk ?? '');
        toolBuffers.set(id, (toolBuffers.get(id)||'') + t);
        pendingUI.set(id, (pendingUI.get(id)||'') + t);
        scheduleFlush();
        return;
      }

      case 'Tool called':
      case 'tool_called': {
        suppressOrchStream = true;
        const toolName = d.name || (d.item && d.item.raw_item && d.item.raw_item.name) || 'Tool';
        const incomingId = d.tool_id || 'tool';
        const key = nameKey(toolName);
        if (!currentAssistantMessage) currentAssistantMessage = createAssistant();

        if (primaryByName.has(key)) {
          const primary = primaryByName.get(key);
          aliasToPrimary.set(incomingId, primary);
          toolBuffers.set(incomingId, '');
          scrollEnd();
          return;
        }

        primaryByName.set(key, incomingId);
        toolStartTimes.set(incomingId, performance.now());
        toolCount++;

        const card = createToolCard(incomingId, toolName);
        currentToolCards.set(incomingId, card);
        toolBuffers.set(incomingId, '');

        const mc = currentAssistantMessage.querySelector('.message-content');
        const main = mc.querySelector('.message-bubble:not(.tool-card .message-bubble)');
        if (main) mc.insertBefore(card, main); else mc.appendChild(card);
        scrollEnd();
        return;
      }

      case 'Tool output':
      case 'Tool output delta': {
        const id = canonicalId(d.tool_id || (d.item && d.item.tool_id) || 'tool');
        const out = (d.item && (d.item.delta ?? d.item.output)) ?? '';
        const t = (typeof out === 'string') ? out
                 : out && typeof out === 'object' ? JSON.stringify(out)
                 : String(out ?? '');
        toolBuffers.set(id, (toolBuffers.get(id)||'') + t);
        pendingUI.set(id, (pendingUI.get(id)||'') + t);
        scheduleFlush();
        return;
      }

      case 'tool_result': {
        const canon = canonicalId(d.tool_id || 'tool');
        const card = currentToolCards.get(canon);

        const t0 = toolStartTimes.get(canon);
        let ms = null;
        if (typeof t0 === 'number') {
          ms = Math.max(0, performance.now() - t0);
          toolElapsed.set(canon, ms);
        }

        const ok = (d.ok !== undefined) ? d.ok
                 : ((d.item && d.item.ok) !== undefined ? d.item.ok : true);

        if (card) {
          const statusChip = card.querySelector('.chip.status');
          if (statusChip) {
            statusChip.textContent = ok ? 'Completed (tap to view)' : 'Failed';
            statusChip.className = 'chip status ' + (ok ? 'completed' : 'failed');
          }
          const timeChip = card.querySelector('[data-timechip]');
          if (timeChip) timeChip.textContent = 'Time: ' + (ms==null ? '‚Äî' : fmtMs(ms));

          const buf = toolBuffers.get(canon) || '';
          renderToolOutput(card, buf, card.querySelector('.tool-name')?.textContent || '');
          card.classList.add('expanded','show-output');
          setTimeout(()=>{
            card.classList.remove('show-output');
            if (!card.dataset.userHold) card.classList.remove('expanded');
          }, 2000);

          const nm = (card.querySelector('.tool-name')?.textContent || '').toLowerCase();
          if (primaryByName.get(nm) === canon) primaryByName.delete(nm);
        }

        if (toolStartTimes.has(canon)) {
          toolStartTimes.delete(canon);
          toolCount = Math.max(0, toolCount - 1);
        }
        if (toolCount === 0) {
          suppressOrchStream = false;
        }
        maybeFinishStreaming();
        return;
      }

      case 'final': {
        const finalText = (typeof d.text === 'string') ? d.text : orchestratorBuf;
        onOrchFinal(finalText || '');
        return;
      }

      case 'ttd_table':
      case 'ctd_table':
      case 'hcdt_table':
        renderTableEvent(d);
        return;

      default:
        return;
    }
  }


  function renderToolOutput(card, output, toolName)
  {
    const outEl = card.querySelector('.tool-output');
    delete outEl.dataset.streamed;

    const toolKey = String(toolName||'').toLowerCase();
    const isDbTool = toolKey.includes('ttd') || toolKey.includes('ctd') || toolKey.includes('hcdt');
    const rows = isDbTool ? extractTableArray(output) : null;

    if (isDbTool && Array.isArray(rows) && rows.length){
      const csv = toCSV(rows);
      const fname = (toolKey || 'table') + '.csv';
      card.dataset.csv = csv; card.dataset.csvFilename = fname;
      outEl.innerHTML =
        `<div style="display:flex;gap:8px;align-items:center;margin:4px 0 10px;justify-content:flex-end">
          <button class="reconnect" onclick="copyCSVFromCard(this)">Copy CSV</button>
          <button class="reconnect" onclick="downloadCSVFromCard(this)">Download CSV</button>
        </div>` + tableHtml(rows,'Results');
      return;
    }

    let obj=null, isTable=false, table=null;
    if (typeof output==='string') {
      try { obj = JSON.parse(output); } catch {}
    } else if (output && typeof output==='object') {
      obj = output;
    }
    if (obj) {
      const t = obj.table || obj?.item?.output?.table;
      if (Array.isArray(t)) { isTable = true; table = t; }
    }

    if (isTable) {
      outEl.innerHTML = tableHtml(table, 'Results');
    } else {
      const text = obj ? JSON.stringify(obj, null, 2) : String(output || '');
      // ‚úÖ Render as Markdown/HTML instead of literal text
      outEl.innerHTML = marked.parse(text);
      outEl.querySelectorAll('pre code').forEach(c => hljs.highlightElement(c));
    }
  }

  // function renderToolOutput(card, output, toolName){
  //   const outEl = card.querySelector('.tool-output');
  //   delete outEl.dataset.streamed;

  //   const toolKey = String(toolName||'').toLowerCase();
  //   const isDbTool = toolKey.includes('ttd') || toolKey.includes('ctd') || toolKey.includes('hcdt');
  //   const rows = isDbTool ? extractTableArray(output) : null;

  //   if (isDbTool && Array.isArray(rows) && rows.length){
  //     const csv = toCSV(rows);
  //     const fname = (toolKey || 'table') + '.csv';
  //     card.dataset.csv = csv; card.dataset.csvFilename = fname;
  //     outEl.innerHTML =
  //       `<div style="display:flex;gap:8px;align-items:center;margin:4px 0 10px;justify-content:flex-end">
  //          <button class="reconnect" onclick="copyCSVFromCard(this)">Copy CSV</button>
  //          <button class="reconnect" onclick="downloadCSVFromCard(this)">Download CSV</button>
  //        </div>` + tableHtml(rows,'Results');
  //     return;
  //   }

  //   let obj=null, isTable=false, table=null;
  //   if (typeof output==='string') {
  //     try { obj = JSON.parse(output); } catch {}
  //   } else if (output && typeof output==='object') {
  //     obj = output;
  //   }
  //   if (obj) {
  //     const t = obj.table || obj?.item?.output?.table;
  //     if (Array.isArray(t)) { isTable = true; table = t; }
  //   }
  //   outEl.textContent = isTable ? '' : (obj ? JSON.stringify(obj,null,2) : String(output || ''));
  //   if (isTable) outEl.innerHTML = tableHtml(table,'Results');
  // }

  function renderTableEvent(ev){
    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const mc = currentAssistantMessage.querySelector('.message-content');

    const label = (ev && ev.row_count != null) ? ('rows: ' + ev.row_count) : 'Ready';

    let downloadLink = '';
    if (ev && ev.csv_path) {
      const url = new URL(
        '/download?path=' + encodeURIComponent(ev.csv_path),
        window.location.origin
      ).toString();
      downloadLink =
        '<a class="reconnect" target="_blank" rel="noopener" href="' +
        url +
        '">üì• Download CSV</a>';
    }

    const card = document.createElement('div');
    card.className = 'tool-card table-card';
    card.innerHTML =
      '<div class="tool-header" onclick="toggleCard(this)">' +
        '<div class="tool-info">' +
          '<div class="tool-icon" title="Table">üìä</div>' +
          '<div class="tool-name">' + esc((ev && ev.type) || 'table') + '</div>' +
          '<div class="tool-chips">' +
            '<div class="chip status completed">' + esc(label) + '</div>' +
            '<div class="chip time" data-timechip>Time: ‚Äî</div>' +
          '</div>' +
        '</div>' +
        '<div class="expand-icon">‚ñæ</div>' +
      '</div>' +
      '<div class="tool-body">' +
        '<div class="tool-output">' +
          '<div class="table-toolbar">' +
            '<div class="pager">' +
              '<button class="pager-prev" disabled>‚óÄ Prev</button>' +
              '<span class="pager-label">Page 1</span>' +
              '<button class="pager-next" disabled>Next ‚ñ∂</button>' +
            '</div>' +
            '<div class="table-actions">' + downloadLink + '</div>' +
          '</div>' +
          '<div class="table-preview" style="min-height:18px;color:var(--mut)">' +
            ((ev && ev.csv_path) ? 'Loading‚Ä¶' : 'No CSV available') +
          '</div>' +
        '</div>' +
      '</div>';

    mc.appendChild(card);
    card.classList.add('expanded');
    setTimeout(()=>{ if(!card.dataset.userHold) card.classList.remove('expanded'); }, 5000);
    scrollEnd();
    if (ev && ev.csv_path) initPaginatedPreview(card, ev.csv_path, 5);
  }

  async function initPaginatedPreview(card, csvPath, rowsPerPage){
    const previewEl = card.querySelector('.table-preview');
    const labelEl   = card.querySelector('.pager-label');
    const prevBtn   = card.querySelector('.pager-prev');
    const nextBtn   = card.querySelector('.pager-next');
    if (!csvPath) { previewEl.textContent = 'No CSV path provided.'; return; }
    try{
      const tStart = performance.now();
      const url = new URL(
        '/download?path=' + encodeURIComponent(csvPath),
        window.location.origin
      ).toString();

      let res = await fetch(url, { headers: { Range: 'bytes=0-350000' } });
      if (!(res.ok || res.status === 206)) res = await fetch(url);
      if (!(res.ok || res.status === 206)) throw new Error('HTTP ' + res.status);
      let text = await res.text();
      text = (text || '').replace(/^\uFEFF/, '');
      if (text && text[text.length-1] !== '\n') text += '\n';
      const parsed = parseCSVHead(text, 50);
      const rows = parsed.rows || [];
      if (!rows.length){
        previewEl.textContent = 'CSV appears empty or could not be parsed.';
        return;
      }
      card._preview = { rows, page:1, rpp:rowsPerPage||5, total:rows.length };
      prevBtn.onclick = ()=>{
        if(card._preview.page>1){
          card._preview.page--;
          renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
        }
      };
      nextBtn.onclick = ()=>{
        const totalPages = Math.ceil(card._preview.total / card._preview.rpp);
        if(card._preview.page<totalPages){
          card._preview.page++;
          renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
        }
      };
      renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
      const timeChip = card.querySelector('[data-timechip]');
      if (timeChip) timeChip.textContent = 'Time: ' + fmtMs(performance.now() - tStart);
    }catch(err){
      console.error('[preview] failed:', err);
      previewEl.textContent = 'Preview failed. (Use Download link)';
    }
  }

  function renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn){
    try{
      const p = card._preview || {};
      const rows = p.rows || [];
      if (!rows.length) { previewEl.textContent = 'No data.'; return; }
      const page = p.page || 1;
      const rpp = p.rpp || 5;
      const total = p.total || rows.length;
      const start = (page-1)*rpp;
      const slice = rows.slice(start, start+rpp);
      const totalPages = Math.max(1, Math.ceil(total/rpp));
      labelEl.textContent = 'Page ' + page + ' of ' + totalPages;
      prevBtn.disabled = (page<=1);
      nextBtn.disabled = (page>=totalPages);
      previewEl.innerHTML = tableHtml(slice, 'Preview ¬∑ rows ' + (start+1) + '-' + Math.min(start+slice.length,total) + ' of ~' + total);
      scrollEnd();
    }catch(e){
      console.error('[preview] render error:', e);
      previewEl.textContent = 'Preview render error.';
    }
  }

  function extractTableArray(raw){
    try{
      const obj = (typeof raw==='string') ? JSON.parse(raw) : raw;
      const t = obj && (obj.table ?? (obj.item && obj.item.output && obj.item.output.table));
      if (Array.isArray(t)) return t;
    }catch(e){}
    if (typeof raw === 'string'){
      const m = raw.match(/table\s*=\s*(\[[\s\S]*?\])\s*(?:\w+\s*=|$)/i);
      if (m){
        let arrTxt = m[1];
        let jsonish = arrTxt
          .replace(/([{,\s])'([^']+?)'\s*:/g, '$1"$2":')
          .replace(/:\s*'([^']*)'/g, ': "$1"')
          .replace(/None\b/g, 'null').replace(/\bTrue\b/g, 'true').replace(/\bFalse\b/g, 'false');
        try{
          const t = JSON.parse(jsonish);
          if (Array.isArray(t)) return t;
        }catch(e){}
      }
    }
    return null;
  }
  function toCSV(rows){
    if(!rows || !rows.length) return '';
    const cols = Array.from(new Set(rows.flatMap(r => Object.keys(r))));
    const escv = (v)=>{
      const s = (v==null ? '' : String(v));
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    };
    const head = cols.join(',');
    const body = rows.map(r => cols.map(c => escv(r[c])).join(',')).join('\n');
    return head + '\n' + body;
  }
  function parseCSVHead(text, maxRows){
    const lines = text.split(/\r?\n/);
    if(!lines.length) return { columns:[], rows:[] };
    let idx=0; while(idx<lines.length && !lines[idx].trim()) idx++;
    if(idx>=lines.length) return { columns:[], rows:[] };
    const columns = parseLine(lines[idx++].replace(/^\uFEFF/,''));

    const rows=[];
    for(; idx<lines.length && rows.length<(maxRows||50); idx++){
      const line = lines[idx]; if(!line) continue;
      const vals = parseLine(line);
      if(vals.length===1 && vals[0]==='') continue;
      const row={}; for(let c=0;c<columns.length;c++) row[columns[c]] = vals[c] ?? '';
      rows.push(row);
    }
    return { columns, rows };
    function parseLine(line){
      const out=[]; let i=0, cur='', inQ=false;
      while(i<line.length){
        const ch=line[i];
        if(inQ){
          if(ch === '"'){
            if(i+1<line.length && line[i+1]==='"'){ cur+='"'; i+=2; }
            else { inQ=false; i++; }
          }else{ cur+=ch; i++; }
        }else{
          if(ch === '"'){ inQ=true; i++; }
          else if(ch === ','){ out.push(cur); cur=''; i++; }
          else { cur+=ch; i++; }
        }
      }
      out.push(cur);
      return out;
    }
  }
  function tableHtml(arr,caption){
    if(!Array.isArray(arr)||!arr.length) return `<div style="color:var(--mut);font-style:italic;padding:6px 2px">[Empty Table]</div>`;
    const cols=Object.keys(arr[0]);
    const thead=`<thead><tr>${cols.map(k=>`<th style="position:sticky;top:0;background:var(--bg3);color:var(--txt);padding:10px 12px;border-bottom:1px solid var(--brd);text-align:left;font-size:13px">${k.replace(/_/g,' ')}</th>`).join('')}</tr></thead>`;
    const tbody=arr.map(r=>`<tr>${cols.map(c=>{
      const v = r[c]==null ? '' : String(r[c]);
      const safe = v.replace(/"/g,'&quot;');
      return `<td style="padding:9px 12px;border-bottom:1px solid var(--brd)"><div style="max-width:600px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${safe}">${safe}</div></td>`;
    }).join('')}</tr>`).join('');
    const cap=caption?`<caption style="text-align:left;color:var(--accent);padding:8px 6px 6px;font-weight:800">üîé ${caption}</caption>`:'';
    return `<div style="width:100%;overflow:auto;margin:.3em 0 .7em 0"><table style="border-collapse:separate;border-spacing:0;width:100%;background:var(--card);border:1px solid var(--brd);border-radius:11px">${cap}${thead}<tbody>${tbody}</tbody></table></div>`;
  }
  function copyCSVFromCard(btn){
    const card = btn.closest('.tool-card');
    const csv = card?.dataset?.csv || '';
    if (!csv) return;
    navigator.clipboard.writeText(csv).then(()=>{
      btn.textContent='Copied!';
      setTimeout(()=>btn.textContent='Copy CSV',900);
    });
  }
  function downloadCSVFromCard(btn){
    const card = btn.closest('.tool-card');
    const csv = card?.dataset?.csv || '';
    const name = card?.dataset?.csvFilename || 'table.csv';
    if (!csv) return;
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  const messageInput=document.getElementById('messageInput');
  const sendButton=document.getElementById('sendButton');
  messageInput.addEventListener('keydown',e=>{
    if(e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      sendMessage();
    }
  });
  messageInput.addEventListener('input',function(){
    this.style.height='auto';
    this.style.height=Math.min(this.scrollHeight,150)+'px';
    const qa = document.getElementById('quickAsks');
    if (qa && messageInput.value.trim().length) qa.style.display = 'none';
  });

  function addUser(text){
    const el=document.createElement('div'); el.className='message user';
    el.innerHTML=`<div class="message-avatar" title="You">üë§</div>
      <div class="message-content">
        <div class="timestamp">${nowStamp()}</div>
        <div class="message-bubble"></div>
      </div>`;
    el.querySelector('.message-bubble').textContent = text;
    document.getElementById('messagesContainer').appendChild(el);
    scrollEnd();
  }

  function kickOffStream(){
    orchestratorDone=false;
    startStreaming();
    currentAssistantMessage=null; currentToolCards.clear();
    orchestratorBuf=''; toolBuffers.clear(); toolCount=0;
    pendingUI.clear();
    suppressOrchStream=false;
    toolStartTimes.clear(); toolElapsed.clear();
  }

  function sendMessage(){
    const txt=messageInput.value.trim();
    if(!txt || !ws || ws.readyState!==WebSocket.OPEN) return;
    addUser(txt);
    ws.send(JSON.stringify({user_input:txt, session_id: activeSessionId}));
    messageInput.value=''; messageInput.style.height='auto';
    kickOffStream();
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = 'none';
  }

  function askPreset(text){
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    addUser(text);
    ws.send(JSON.stringify({ user_input: text, session_id: activeSessionId }));
    messageInput.value=''; messageInput.style.height='auto';
    kickOffStream();
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = 'none';
  }
  function showQuickAsks(){
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = '';
  }

  function initTheme(){
    try{
      const saved = localStorage.getItem('biochirp_theme');
      if (saved) document.documentElement.setAttribute('data-theme', saved);
    }catch{}
    document.getElementById('themeToggle')?.addEventListener('click', ()=>{
      const cur = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = (cur==='dark') ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      try{ localStorage.setItem('biochirp_theme', next); }catch{}
    });
  }
</script>
</body>
</html>
