<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>BioChirp - Biological Research AI (Chat)</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/common.min.js"></script>

<style>
  :root[data-theme="dark"]{
    --bg0:#070A15; --bg1:#0B1222; --bg2:#0E1626; --bg3:#121C2E;
    --card:#0F1828; --txt:#EAF2FF; --mut:#9FB0C4;
    --brd:rgba(255,255,255,.10); --hover:rgba(255,255,255,.06);
    --accent:#1FA4FF; --accent2:#A78BFA; --ok:#00E38C; --err:#ff6b6b;
    --shadow:0 18px 55px rgba(0,0,0,.45);
  }
  :root[data-theme="light"]{
    --bg0:#F6FAFF; --bg1:#FFFFFF; --bg2:#FFFFFF; --bg3:#F4F7FB;
    --card:#FFFFFF; --txt:#0B1624; --mut:#486173;
    --brd:rgba(0,0,0,.10); --hover:rgba(0,0,0,.04);
    --accent:#1FA4FF; --accent2:#6D50FF; --ok:#0FB27A; --err:#E25050;
    --shadow:0 18px 55px rgba(17,24,39,.14);
  }
  :root{ --chat-max: 1200px; }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    min-height:100vh; color:var(--txt); background:var(--bg0);
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column;
    background:
      radial-gradient(900px 600px at -20% -10%, rgba(31,164,255,.10) 0%, transparent 60%),
      radial-gradient(900px 600px at 110% 110%, rgba(167,139,250,.10) 0%, transparent 55%),
      linear-gradient(135deg,var(--bg0) 0%,var(--bg1) 100%);
  }

  .app{display:flex; min-height:100vh;}
  .chat{flex:1; display:flex; flex-direction:column; min-width:0;}

  .chat-header{
    position:sticky; top:0; z-index:5; padding:10px 16px;
    border-bottom:1px solid var(--brd);
    display:flex; align-items:center; justify-content:space-between;
    background:color-mix(in oklab, var(--bg1) 86%, transparent);
    backdrop-filter: blur(10px) saturate(1.25);
  }
  .leftHdr{display:flex; align-items:center; gap:10px}
  .chat-title{font-size:18px; font-weight:800; letter-spacing:.01em}
  .chat-title small{font-weight:700; color:var(--mut); font-size:12px}
  .status-wrap{display:flex; gap:8px; align-items:center}
  .connection-status{
    display:flex; gap:8px; align-items:center; padding:6px 10px;
    border-radius:999px; border:1px solid var(--brd);
    background:var(--bg2); font-size:12px
  }
  .status-dot{width:9px;height:9px;border-radius:50%;background:var(--ok)}
  .reconnect,.theme-btn,.share-btn{
    padding:6px 10px;border-radius:10px;border:1px solid var(--brd);
    background:var(--bg2);color:var(--txt);cursor:pointer;font-size:12px;
    display:inline-flex;align-items:center;gap:6px;
    transition:background .15s ease, transform .06s ease, border-color .15s ease;
  }
  .reconnect:hover,.theme-btn:hover,.share-btn:hover{
    background:var(--hover); border-color:color-mix(in oklab,var(--accent) 30%,var(--brd));
  }
  .reconnect:active,.theme-btn:active,.share-btn:active{ transform:translateY(1px) }

  .toast{
    position:fixed; right:16px; bottom:16px; z-index:50;
    background:var(--card); color:var(--txt);
    border:1px solid var(--brd); border-radius:12px; padding:12px;
    box-shadow:var(--shadow); max-width:90vw; width:420px
  }
  .toast h4{margin:0 0 6px 0; font-size:14px}
  .toast .row{display:flex; gap:8px; align-items:center}
  .toast input{
    flex:1; background:var(--bg2); color:var(--txt);
    border:1px solid var(--brd); border-radius:8px; padding:8px 10px; font-size:12px
  }
  .toast .btns{display:flex; gap:8px; margin-top:8px; justify-content:flex-end}

  .quick-asks{
    max-width: var(--chat-max);
    margin: 10px auto 0;
    padding: 0 16px;
    display:grid;
    grid-template-columns: repeat(4, minmax(0,1fr));
    gap:10px;
  }
  .qa-card{
    border:1px solid var(--brd);
    background:radial-gradient(circle at top left, rgba(31,164,255,.12), transparent 55%), var(--card);
    color:var(--txt);
    padding:12px 14px;
    border-radius:14px;
    font-size:13px;
    cursor:pointer;
    box-shadow: var(--shadow);
    transition: transform .06s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
    user-select:none;
  }
  .qa-card:hover{
    background:radial-gradient(circle at bottom right, rgba(167,139,250,.18), transparent 55%), var(--bg2);
    border-color: color-mix(in oklab, var(--accent) 35%, var(--brd));
    box-shadow: 0 16px 45px rgba(0,0,0,.38);
  }
  .qa-card:active{ transform: translateY(1px) scale(.99); }

  .messages{
    flex:1; overflow-y:auto; padding:16px;
    display:flex; flex-direction:column; gap:14px;
  }
  .message{display:flex; gap:12px; max-width:var(--chat-max); margin-inline:auto;}
  .message.user{align-self:flex-end; flex-direction:row-reverse; margin-left:auto; margin-right:0;}
  .message-avatar{
    width:36px;height:36px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    background:#fff;color:#0b1222;border:1px solid var(--brd);
    font-size:18px;
    box-shadow:0 4px 16px rgba(0,0,0,.25);
  }
  .message-avatar img{
    width:100%; height:100%; border-radius:12px;
    display:block; background:transparent;
  }
  .message-content{flex:1; display:flex; flex-direction:column; gap:8px; min-width:0}
  .timestamp{font-size:11px; color:var(--mut)}
  .message-bubble{
    position:relative; padding:12px 14px; border-radius:16px;
    background:var(--card); border:1px solid var(--brd);
    line-height:1.6; font-size:15px; overflow-wrap:anywhere;
    box-shadow:var(--shadow);
  }
  .message.user .message-bubble{
    background:linear-gradient(135deg,rgba(31,164,255,.15),rgba(167,139,250,.18)), var(--card);
    border-color:color-mix(in oklab,var(--accent) 55%, var(--brd));
  }
  .message.assistant .message-bubble pre{
    background:var(--bg3);border:1px solid var(--brd);
    border-radius:12px;padding:12px;overflow:auto
  }
  .message.assistant .message-bubble code{
    background:var(--bg3);border:1px solid var(--brd);
    padding:2px 6px;border-radius:6px
  }

  .tool-card{background:var(--card);border:1px solid var(--brd);border-radius:12px;overflow:hidden;margin-top:6px}
  .tool-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;cursor:pointer}
  .tool-info{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .tool-icon{
    width:22px;height:22px;border-radius:6px;
    display:flex;align-items:center;justify-content:center;
    background:#fff;color:#0b1222;border:1px solid var(--brd);font-size:12px
  }
  .tool-name{font-weight:800;font-size:13px}
  .tool-chips{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  .chip{font-size:11px;padding:3px 8px;border-radius:10px;font-weight:700;border:1px solid var(--brd);background:var(--bg2);color:var(--mut)}
  .chip.status.running{color:#ffd76a}
  .chip.status.completed{color:#63ffb3}
  .chip.status.failed{color:#ff9c9c}
  .chip.time{color:var(--txt)}
  .expand-icon{transition:.25s;color:var(--mut)}
  .tool-card.expanded .expand-icon{transform:rotate(180deg)}
  .tool-body{max-height:0;overflow:hidden;transition:max-height .3s}
  .tool-card.expanded .tool-body,
  .tool-card.show-output .tool-body{max-height:70vh;overflow:auto}
  .tool-output{padding:12px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:14px;white-space:pre-wrap;word-break:break-word}

  .table-toolbar{
    display:flex; align-items:center; justify-content:space-between;
    gap:8px; margin:2px 0 8px;
  }
  .table-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .pager{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--mut); flex-wrap:wrap; }
  .pager button{
    padding:6px 10px; border-radius:10px; border:1px solid var(--brd);
    background:var(--bg2); color:var(--txt); cursor:pointer; font-size:12px;
  }
  .pager button:disabled{ opacity:.5; cursor:not-allowed; }

  .input-area{
    padding:12px 14px;border-top:1px solid var(--brd);
    background:color-mix(in oklab, var(--bg1) 92%, transparent);
    backdrop-filter: blur(10px) saturate(1.2);
  }
  .input-container{display:flex;gap:10px;align-items:flex-end; max-width:var(--chat-max); margin:0 auto}
  .input-wrapper{flex:1}
  #messageInput{
    width:100%;min-height:48px;max-height:150px;padding:12px 14px;
    border-radius:12px;outline:none;resize:none;
    background:var(--card);border:1px solid var(--brd);
    color:var(--txt);font-size:14px;
    box-shadow:var(--shadow);
  }
  #messageInput::placeholder{ color:color-mix(in oklab,var(--mut) 80%, transparent); }
  #sendButton{
    width:52px;height:52px;border:none;border-radius:14px;
    color:#00162a;cursor:pointer;font-size:20px;
    background:linear-gradient(135deg,var(--accent),var(--accent2));
    box-shadow:var(--shadow);
    display:flex;align-items:center;justify-content:center;
    transition:transform .06s ease, box-shadow .15s ease, opacity .15s ease;
  }
  #sendButton:disabled{ opacity:.45; cursor:not-allowed; }
  #sendButton:not(:disabled):active{ transform:translateY(1px) scale(.98); box-shadow:0 8px 24px rgba(0,0,0,.4); }

  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }

  @media (max-width: 920px){
    .message{max-width:100%}
    .quick-asks{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    .chat-header{flex-direction:column;align-items:flex-start;gap:8px}
    .status-wrap{align-self:stretch;justify-content:flex-start;flex-wrap:wrap}
  }

  /* For snapshot: when .tool-card becomes <details> */
  details.tool-card {
    border-radius: 12px;
    border: 1px solid var(--brd);
    background: var(--card);
    overflow: hidden;
  }

  /* Reuse existing header styles on <summary> */
  details.tool-card > summary.tool-header {
    list-style: none;
  }

  /* Hide default disclosure triangle */
  details.tool-card > summary.tool-header::-webkit-details-marker {
    display: none;
  }

  /* Rotate your custom caret when open */
  details.tool-card[open] .expand-icon {
    transform: rotate(180deg);
  }

  /* In snapshot we don‚Äôt need animated max-height, let details handle it */
  details.tool-card .tool-body {
    max-height: none !important;
    overflow: visible !important;
  }
</style>
</head>
<body>
<div class="app">
  <main class="chat">
    <header class="chat-header">
      <div class="leftHdr">
        <div class="chat-title">
          Research Chat <small>‚Ä¢ Biological Intelligence</small>
        </div>
      </div>
      <div class="status-wrap">
        <button class="theme-btn" id="themeToggle">üåì Theme</button>
        <button class="share-btn" id="shareBtn" title="Create a public share link">üîó Share</button>
        <button class="reconnect" onclick="manualReconnect()">‚ü≥ Reconnect</button>
        <div class="connection-status">
          <div class="status-dot" id="statusDot"></div>
          <span id="connectionStatus">Connecting‚Ä¶</span>
        </div>
      </div>
    </header>

    <div id="quickAsks" class="quick-asks" aria-label="Quick questions">
      <div class="qa-card" onclick="askPreset('What are the drugs for TB?')">üíä What are the drugs for TB?</div>
      <div class="qa-card" onclick="askPreset('List the TKI.')">üéØ List the TKI</div>
      <div class="qa-card" onclick="askPreset('What are the genes linked to asthma?')">üß¨ Genes linked to asthma</div>
      <div class="qa-card" onclick="askPreset('What are the pathway and biomarker linked to melanoma?')">üß™ Pathways & biomarkers in melanoma</div>
    </div>

    <section class="messages" id="messagesContainer"></section>

    <footer class="input-area">
      <div class="input-container">
        <div class="input-wrapper">
          <textarea id="messageInput" placeholder="Ask about drugs, pathways, biomarkers, or clinical data..." rows="1"></textarea>
        </div>
        <button id="sendButton" title="Send" onclick="sendMessage()">‚û§</button>
      </div>
    </footer>
  </main>
</div>

<script>
  // const WS_URL = 'wss://biochirp.iiitd.edu.in/chat';
  const WS_URL = 'wss://biochirp.iiitd.edu.in/chat/';

  marked.setOptions({
    gfm:true, breaks:true, mangle:false, headerIds:false,
    highlight:(code,lang)=>{ try{return hljs.highlight(code,{language:lang}).value;}catch{return hljs.highlightAuto(code).value;} }
  });

  let ws=null, pingInterval=null;
  let currentAssistantMessage=null;
  let currentToolCards=new Map();
  let toolBuffers=new Map();
  let toolCount=0;

  const toolStartTimes = new Map();
  const toolElapsed = new Map();

  let orchestratorDone=false;
  let isStreaming=false;

  let orchestratorBuf='';
  let suppressOrchStream=false;

  let pendingUI = new Map();
  let rafScheduled = false;

  const primaryByName = new Map();   // name -> primary tool_id
  const aliasToPrimary = new Map();  // aliasId -> primaryId
  const nameKey = (n)=> String(n||'tool').trim().toLowerCase();
  const canonicalId = (raw)=> aliasToPrimary.get(raw) || raw || 'tool';

  const activeSessionId = 'sess_' + Math.random().toString(36).slice(2,10);

  function setStatus(t,ok){
    document.getElementById('connectionStatus').textContent=t;
    document.getElementById('statusDot').style.background=ok?'var(--ok)':'var(--err)';
  }
  function startPing(){
    clearInterval(pingInterval);
    pingInterval=setInterval(()=>{
      if(ws&&ws.readyState===WebSocket.OPEN){
        ws.send(JSON.stringify({type:'ping',ts:Date.now()}));
      }
    },30000);
  }
  function nowStamp(){ return new Date().toLocaleString(); }
  function scrollEnd(){
    const mc=document.getElementById('messagesContainer');
    mc.scrollTop=mc.scrollHeight;
  }
  function esc(s){
    const d=document.createElement('div');
    d.textContent=s==null?'':String(s);
    return d.innerHTML;
  }

  // Only disable input when socket is not open (not while streaming)
  function disableInput(){
    document.getElementById('messageInput').disabled=true;
    document.getElementById('sendButton').disabled=true;
  }
  function enableInput(){
    document.getElementById('messageInput').disabled=false;
    document.getElementById('sendButton').disabled=false;
  }

  function startStreaming(){ isStreaming=true; }
  function maybeFinishStreaming(){
    if (orchestratorDone && toolCount===0) {
      isStreaming=false;
    }
  }

  function connect(){
    try{ ws && ws.close(); }catch{}
    disableInput();
    ws=new WebSocket(WS_URL);
    ws.onopen=()=>{
      setStatus('Connected',true);
      startPing();
      enableInput();
    };
    ws.onclose=()=>{
      setStatus('Disconnected',false);
      disableInput();
      setTimeout(connect,1500);
    };
    ws.onerror=()=>{
      setStatus('Error',false);
      disableInput();
    };
    ws.onmessage=(e)=>{
      let d;
      try{ d = JSON.parse(e.data); }catch{ return; }
      route(d);
    };
  }
  window.addEventListener('load', ()=>{
    resetChatUI();
    connect();
    initTheme();
  });
  function manualReconnect(){
    try{ if(ws) ws.close(); }catch{}
    connect();
  }

  function resetChatUI(){
    const mc=document.getElementById('messagesContainer');
    mc.innerHTML = `
      <div class="message assistant">
        <div class="message-avatar" title="Assistant">
          <img src="assets/brand/logo.svg" alt="Assistant">
        </div>
        <div class="message-content">
          <div class="timestamp">${nowStamp()}</div>
          <div class="message-bubble">Welcome to **BioChirp**! Ask about drugs, pathways, biomarkers, or clinical data.</div>
        </div>
      </div>`;
    currentAssistantMessage=null; currentToolCards.clear(); orchestratorBuf='';
    toolBuffers.clear(); toolCount=0; suppressOrchStream=false;
    orchestratorDone=false; isStreaming=false;
    toolStartTimes.clear(); toolElapsed.clear();
    const last = mc.querySelector('.message-bubble');
    if(last){
      last.innerHTML = marked.parse(last.textContent);
      last.querySelectorAll('pre code').forEach(c=>hljs.highlightElement(c));
    }
    scrollEnd();
    showQuickAsks();
  }

  function createAssistant(){
    const el=document.createElement('div'); el.className='message assistant';
    el.innerHTML=`<div class="message-avatar" title="Assistant">
        <img src="assets/brand/logo.svg" alt="Assistant">
      </div>
      <div class="message-content">
        <div class="timestamp">${nowStamp()}</div>
        <div class="message-bubble"></div>
      </div>`;
    document.getElementById('messagesContainer').appendChild(el);
    return el;
  }
  function mainBubble(msgDiv){
    const mc=msgDiv.querySelector('.message-content');
    let b=[...mc.querySelectorAll('.message-bubble')].find(x=>!x.closest('.tool-card'));
    if(!b){
      b=document.createElement('div');
      b.className='message-bubble';
      mc.appendChild(b);
    }
    return b;
  }
  function toolClass(n){
    n=(n||'').toLowerCase();
    if(n.includes('ttd')||n.includes('ctd')||n.includes('hcdt'))return'table-card';
    if(n.includes('web'))return'tool-web';
    if(n.includes('interpreter'))return'tool-interpreter';
    return'tool-generic';
  }
  function toolEmoji(n){
    n = String(n||'').toLowerCase();
    if (n.includes('ttd'))          return 'üéØ';
    if (n.includes('ctd'))          return 'üß™';
    if (n.includes('hcdt'))         return 'üíä';
    if (n.includes('web'))          return 'üåê';
    if (n.includes('interpreter'))  return 'üß†';
    if (n.includes('readme'))       return 'üìñ';
    if (n.includes('memory'))       return 'üóÇÔ∏è';
    if (n.includes('tavily') || n.includes('search')) return 'üîé';
    if (n.includes('orchestrator')) return 'ü§ñ';
    return 'üõ†Ô∏è';
  }
  function fmtMs(ms){
    if (ms < 1000) return Math.max(0, Math.round(ms)) + ' ms';
    const s = ms/1000;
    return (s<60) ? s.toFixed(2) + ' s' : (s/60).toFixed(2) + ' min';
  }

  function createToolCard(id,name){
    const c=document.createElement('div');
    c.className=`tool-card ${toolClass(name)}`; c.dataset.toolId=id;
    const icon = toolEmoji(name);
    c.innerHTML=`<div class="tool-header" onclick="toggleCard(this)">
        <div class="tool-info">
          <div class="tool-icon">${icon}</div>
          <div class="tool-name">${esc(name||'Tool')}</div>
          <div class="tool-chips">
            <div class="chip status running">Running‚Ä¶</div>
            <div class="chip time" data-timechip>Time: ‚Äî</div>
          </div>
        </div>
        <div class="expand-icon">‚ñæ</div>
      </div>
      <div class="tool-body">
        <div class="tool-output">Streaming‚Ä¶</div>
      </div>`;
    return c;
  }
  function toggleCard(h){
    const c = h.closest('.tool-card');
    c.classList.toggle('expanded');
    if (c.classList.contains('expanded')) c.dataset.userHold = '1';
  }
  function scheduleFlush(){
    if (rafScheduled) return;
    rafScheduled = true;
    requestAnimationFrame(() => {
      rafScheduled = false;
      for (const [id, chunk] of pendingUI.entries()) {
        pendingUI.delete(id);
        const card = currentToolCards.get(id);
        if (!card) continue;
        const outEl = card.querySelector('.tool-output');
        if (!outEl.dataset.streamed) { outEl.dataset.streamed = '1'; outEl.textContent = ''; }
        if (chunk) outEl.textContent += chunk;
        card.classList.add('expanded');
      }
      scrollEnd();
    });
  }

  function sanitizeOrchestrator(content){
    if (!content) return '';
    const t = content.trim();
    const startsWithEcho = /^\s*`{0,3}\s*"?input[_ ]?query"?\s*[:=>]/i.test(t);
    const shortEcho = t.length <= 500 && /input[_ ]?query/i.test(t) && !/\n.*\n.*\n/.test(t);
    const fencedEcho = /^```[\s\S]*?input[_ ]?query[\s\S]*?```$/i.test(t) && !/```[\s\S]*?```[\s\S]*?```/i.test(t);
    return (startsWithEcho || shortEcho || fencedEcho) ? '' : content;
  }

  function onOrchDelta(text){
    if (!text) return;
    const maybe = sanitizeOrchestrator(text);
    if (!maybe) return;

    orchestratorBuf += maybe;
    if (suppressOrchStream) return;

    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const bubble = mainBubble(currentAssistantMessage);
    bubble.innerHTML = marked.parse(orchestratorBuf) +
      `<span style="display:inline-block;width:2px;height:1em;background:var(--accent);margin-left:2px;animation:blink 1s infinite"></span>`;
    bubble.querySelectorAll('pre code').forEach(c => hljs.highlightElement(c));
    scrollEnd();
  }
  function onOrchFinal(text){
    const cleaned = sanitizeOrchestrator(text);
    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const bubble = mainBubble(currentAssistantMessage);
    bubble.innerHTML = marked.parse(cleaned || orchestratorBuf || '');
    bubble.querySelectorAll('pre code').forEach(c=>hljs.highlightElement(c));
    orchestratorBuf = '';
    orchestratorDone = true;
    maybeFinishStreaming();
    scrollEnd();
  }

  function route(d){
    switch(d.type){
      case 'heartbeat':
      case 'pong':
      case 'user_ack':
        return;

      case 'orchestrator_delta':
        onOrchDelta(d.content);
        return;

      case 'orchestrator_final':
        onOrchFinal(d.content);
        return;

      case 'delta': {
        const nm = String(d.name||'').toLowerCase();
        const isOrch = nm.includes('orchestrator') || (d.tool_id||'') === 'orchestrator';
        const chunk = d.text ?? d.delta ?? d.content ?? '';
        if (isOrch) {
          onOrchDelta(chunk);
          return;
        }
        const id = canonicalId(d.tool_id || 'tool');
        const t = String(chunk ?? '');
        toolBuffers.set(id, (toolBuffers.get(id)||'') + t);
        pendingUI.set(id, (pendingUI.get(id)||'') + t);
        scheduleFlush();
        return;
      }

      case 'Tool called':
      case 'tool_called': {
        suppressOrchStream = true;
        const toolName = d.name || (d.item && d.item.raw_item && d.item.raw_item.name) || 'Tool';
        const incomingId = d.tool_id || 'tool';
        const key = nameKey(toolName);
        if (!currentAssistantMessage) currentAssistantMessage = createAssistant();

        if (primaryByName.has(key)) {
          const primary = primaryByName.get(key);
          aliasToPrimary.set(incomingId, primary);
          toolBuffers.set(incomingId, '');
          scrollEnd();
          return;
        }

        primaryByName.set(key, incomingId);
        toolStartTimes.set(incomingId, performance.now());
        toolCount++;

        const card = createToolCard(incomingId, toolName);
        currentToolCards.set(incomingId, card);
        toolBuffers.set(incomingId, '');

        const mc = currentAssistantMessage.querySelector('.message-content');
        const main = mc.querySelector('.message-bubble:not(.tool-card .message-bubble)');
        if (main) mc.insertBefore(card, main); else mc.appendChild(card);
        scrollEnd();
        return;
      }

      case 'Tool output':
      case 'Tool output delta': {
        const id = canonicalId(d.tool_id || (d.item && d.item.tool_id) || 'tool');
        const out = (d.item && (d.item.delta ?? d.item.output)) ?? '';
        const t = (typeof out === 'string') ? out
                 : out && typeof out === 'object' ? JSON.stringify(out)
                 : String(out ?? '');
        toolBuffers.set(id, (toolBuffers.get(id)||'') + t);
        pendingUI.set(id, (pendingUI.get(id)||'') + t);
        scheduleFlush();
        return;
      }

      case 'tool_result': {
        const canon = canonicalId(d.tool_id || 'tool');
        const card = currentToolCards.get(canon);

        const t0 = toolStartTimes.get(canon);
        let ms = null;
        if (typeof t0 === 'number') {
          ms = Math.max(0, performance.now() - t0);
          toolElapsed.set(canon, ms);
        }

        const ok = (d.ok !== undefined) ? d.ok
                 : ((d.item && d.item.ok) !== undefined ? d.item.ok : true);

        if (card) {
          const statusChip = card.querySelector('.chip.status');
          if (statusChip) {
            statusChip.textContent = ok ? 'Completed (tap to view)' : 'Failed';
            statusChip.className = 'chip status ' + (ok ? 'completed' : 'failed');
          }
          const timeChip = card.querySelector('[data-timechip]');
          if (timeChip) timeChip.textContent = 'Time: ' + (ms==null ? '‚Äî' : fmtMs(ms));

          const buf = toolBuffers.get(canon) || '';
          renderToolOutput(card, buf, card.querySelector('.tool-name')?.textContent || '');
          card.classList.add('expanded','show-output');
          setTimeout(()=>{
            card.classList.remove('show-output');
            if (!card.dataset.userHold) card.classList.remove('expanded');
          }, 2000);

          const nm = (card.querySelector('.tool-name')?.textContent || '').toLowerCase();
          if (primaryByName.get(nm) === canon) primaryByName.delete(nm);
        }

        if (toolStartTimes.has(canon)) {
          toolStartTimes.delete(canon);
          toolCount = Math.max(0, toolCount - 1);
        }
        if (toolCount === 0) {
          suppressOrchStream = false;
        }
        maybeFinishStreaming();
        return;
      }

      case 'final': {
        const finalText = (typeof d.text === 'string') ? d.text : orchestratorBuf;
        onOrchFinal(finalText || '');
        return;
      }

      case 'ttd_table':
      case 'ctd_table':
      case 'hcdt_table':
        renderTableEvent(d);
        return;

      default:
        return;
    }
  }

  function renderToolOutput(card, output, toolName){
    const outEl = card.querySelector('.tool-output');
    delete outEl.dataset.streamed;

    const toolKey = String(toolName||'').toLowerCase();
    const isDbTool = toolKey.includes('ttd') || toolKey.includes('ctd') || toolKey.includes('hcdt');
    const rows = isDbTool ? extractTableArray(output) : null;

    if (isDbTool && Array.isArray(rows) && rows.length){
      const csv = toCSV(rows);
      const fname = (toolKey || 'table') + '.csv';
      card.dataset.csv = csv; card.dataset.csvFilename = fname;
      outEl.innerHTML =
        `<div style="display:flex;gap:8px;align-items:center;margin:4px 0 10px;justify-content:flex-end">
           <button class="reconnect" onclick="copyCSVFromCard(this)">Copy CSV</button>
           <button class="reconnect" onclick="downloadCSVFromCard(this)">Download CSV</button>
         </div>` + tableHtml(rows,'Results');
      return;
    }

    let obj=null, isTable=false, table=null;
    if (typeof output==='string') {
      try { obj = JSON.parse(output); } catch {}
    } else if (output && typeof output==='object') {
      obj = output;
    }
    if (obj) {
      const t = obj.table || obj?.item?.output?.table;
      if (Array.isArray(t)) { isTable = true; table = t; }
    }
    outEl.textContent = isTable ? '' : (obj ? JSON.stringify(obj,null,2) : String(output || ''));
    if (isTable) outEl.innerHTML = tableHtml(table,'Results');
  }

  function renderTableEvent(ev){
    if (!currentAssistantMessage) currentAssistantMessage = createAssistant();
    const mc = currentAssistantMessage.querySelector('.message-content');

    const label = (ev && ev.row_count != null) ? ('rows: ' + ev.row_count) : 'Ready';

    let downloadLink = '';
    if (ev && ev.csv_path) {
      const url = new URL(
        '/download?path=' + encodeURIComponent(ev.csv_path),
        window.location.origin
      ).toString();
      downloadLink =
        '<a class="reconnect" target="_blank" rel="noopener" href="' +
        url +
        '">üì• Download CSV</a>';
    }

    const card = document.createElement('div');
    card.className = 'tool-card table-card';
    card.innerHTML =
      '<div class="tool-header" onclick="toggleCard(this)">' +
        '<div class="tool-info">' +
          '<div class="tool-icon" title="Table">üìä</div>' +
          '<div class="tool-name">' + esc((ev && ev.type) || 'table') + '</div>' +
          '<div class="tool-chips">' +
            '<div class="chip status completed">' + esc(label) + '</div>' +
            '<div class="chip time" data-timechip>Time: ‚Äî</div>' +
          '</div>' +
        '</div>' +
        '<div class="expand-icon">‚ñæ</div>' +
      '</div>' +
      '<div class="tool-body">' +
        '<div class="tool-output">' +
          '<div class="table-toolbar">' +
            '<div class="pager">' +
              '<button class="pager-prev" disabled>‚óÄ Prev</button>' +
              '<span class="pager-label">Page 1</span>' +
              '<button class="pager-next" disabled>Next ‚ñ∂</button>' +
            '</div>' +
            '<div class="table-actions">' + downloadLink + '</div>' +
          '</div>' +
          '<div class="table-preview" style="min-height:18px;color:var(--mut)">' +
            ((ev && ev.csv_path) ? 'Loading‚Ä¶' : 'No CSV available') +
          '</div>' +
        '</div>' +
      '</div>';

    mc.appendChild(card);
    card.classList.add('expanded');
    setTimeout(()=>{ if(!card.dataset.userHold) card.classList.remove('expanded'); }, 5000);
    scrollEnd();
    if (ev && ev.csv_path) initPaginatedPreview(card, ev.csv_path, 5);
  }

  async function initPaginatedPreview(card, csvPath, rowsPerPage){
    const previewEl = card.querySelector('.table-preview');
    const labelEl   = card.querySelector('.pager-label');
    const prevBtn   = card.querySelector('.pager-prev');
    const nextBtn   = card.querySelector('.pager-next');
    if (!csvPath) { previewEl.textContent = 'No CSV path provided.'; return; }
    try{
      const tStart = performance.now();
      const url = new URL(
        '/download?path=' + encodeURIComponent(csvPath),
        window.location.origin
      ).toString();

      let res = await fetch(url, { headers: { Range: 'bytes=0-350000' } });
      if (!(res.ok || res.status === 206)) res = await fetch(url);
      if (!(res.ok || res.status === 206)) throw new Error('HTTP ' + res.status);
      let text = await res.text();
      text = (text || '').replace(/^\uFEFF/, '');
      if (text && text[text.length-1] !== '\n') text += '\n';
      const parsed = parseCSVHead(text, 300);
      const rows = parsed.rows || [];
      if (!rows.length){
        previewEl.textContent = 'CSV appears empty or could not be parsed.';
        return;
      }
      card._preview = { rows, page:1, rpp:rowsPerPage||5, total:rows.length };
      prevBtn.onclick = ()=>{
        if(card._preview.page>1){
          card._preview.page--;
          renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
        }
      };
      nextBtn.onclick = ()=>{
        const totalPages = Math.ceil(card._preview.total / card._preview.rpp);
        if(card._preview.page<totalPages){
          card._preview.page++;
          renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
        }
      };
      renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn);
      const timeChip = card.querySelector('[data-timechip]');
      if (timeChip) timeChip.textContent = 'Time: ' + fmtMs(performance.now() - tStart);
    }catch(err){
      console.error('[preview] failed:', err);
      previewEl.textContent = 'Preview failed. (Use Download link)';
    }
  }

  function renderPreviewPage(card, labelEl, previewEl, prevBtn, nextBtn){
    try{
      const p = card._preview || {};
      const rows = p.rows || [];
      if (!rows.length) { previewEl.textContent = 'No data.'; return; }
      const page = p.page || 1;
      const rpp = p.rpp || 5;
      const total = p.total || rows.length;
      const start = (page-1)*rpp;
      const slice = rows.slice(start, start+rpp);
      const totalPages = Math.max(1, Math.ceil(total/rpp));
      labelEl.textContent = 'Page ' + page + ' of ' + totalPages;
      prevBtn.disabled = (page<=1);
      nextBtn.disabled = (page>=totalPages);
      previewEl.innerHTML = tableHtml(slice, 'Preview ¬∑ rows ' + (start+1) + '-' + Math.min(start+slice.length,total) + ' of ~' + total);
      scrollEnd();
    }catch(e){
      console.error('[preview] render error:', e);
      previewEl.textContent = 'Preview render error.';
    }
  }

  function extractTableArray(raw){
    try{
      const obj = (typeof raw==='string') ? JSON.parse(raw) : raw;
      const t = obj && (obj.table ?? (obj.item && obj.item.output && obj.item.output.table));
      if (Array.isArray(t)) return t;
    }catch(e){}
    if (typeof raw === 'string'){
      const m = raw.match(/table\s*=\s*(\[[\s\S]*?\])\s*(?:\w+\s*=|$)/i);
      if (m){
        let arrTxt = m[1];
        let jsonish = arrTxt
          .replace(/([{,\s])'([^']+?)'\s*:/g, '$1"$2":')
          .replace(/:\s*'([^']*)'/g, ': "$1"')
          .replace(/None\b/g, 'null').replace(/\bTrue\b/g, 'true').replace(/\bFalse\b/g, 'false');
        try{
          const t = JSON.parse(jsonish);
          if (Array.isArray(t)) return t;
        }catch(e){}
      }
    }
    return null;
  }
  function toCSV(rows){
    if(!rows || !rows.length) return '';
    const cols = Array.from(new Set(rows.flatMap(r => Object.keys(r))));
    const escv = (v)=>{
      const s = (v==null ? '' : String(v));
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    };
    const head = cols.join(',');
    const body = rows.map(r => cols.map(c => escv(r[c])).join(',')).join('\n');
    return head + '\n' + body;
  }
  function parseCSVHead(text, maxRows){
    const lines = text.split(/\r?\n/);
    if(!lines.length) return { columns:[], rows:[] };
    let idx=0; while(idx<lines.length && !lines[idx].trim()) idx++;
    if(idx>=lines.length) return { columns:[], rows:[] };
    const columns = parseLine(lines[idx++].replace(/^\uFEFF/,''));
    const rows=[];
    for(; idx<lines.length && rows.length<(maxRows||50); idx++){
      const line = lines[idx]; if(!line) continue;
      const vals = parseLine(line);
      if(vals.length===1 && vals[0]==='') continue;
      const row={}; for(let c=0;c<columns.length;c++) row[columns[c]] = vals[c] ?? '';
      rows.push(row);
    }
    return { columns, rows };
    function parseLine(line){
      const out=[]; let i=0, cur='', inQ=false;
      while(i<line.length){
        const ch=line[i];
        if(inQ){
          if(ch === '"'){
            if(i+1<line.length && line[i+1]==='"'){ cur+='"'; i+=2; }
            else { inQ=false; i++; }
          }else{ cur+=ch; i++; }
        }else{
          if(ch === '"'){ inQ=true; i++; }
          else if(ch === ','){ out.push(cur); cur=''; i++; }
          else { cur+=ch; i++; }
        }
      }
      out.push(cur);
      return out;
    }
  }
  function tableHtml(arr,caption){
    if(!Array.isArray(arr)||!arr.length) return `<div style="color:var(--mut);font-style:italic;padding:6px 2px">[Empty Table]</div>`;
    const cols=Object.keys(arr[0]);
    const thead=`<thead><tr>${cols.map(k=>`<th style="position:sticky;top:0;background:var(--bg3);color:var(--txt);padding:10px 12px;border-bottom:1px solid var(--brd);text-align:left;font-size:13px">${k.replace(/_/g,' ')}</th>`).join('')}</tr></thead>`;
    const tbody=arr.map(r=>`<tr>${cols.map(c=>{
      const v = r[c]==null ? '' : String(r[c]);
      const safe = v.replace(/"/g,'&quot;');
      return `<td style="padding:9px 12px;border-bottom:1px solid var(--brd)"><div style="max-width:600px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${safe}">${safe}</div></td>`;
    }).join('')}</tr>`).join('');
    const cap=caption?`<caption style="text-align:left;color:var(--accent);padding:8px 6px 6px;font-weight:800">üîé ${caption}</caption>`:'';
    return `<div style="width:100%;overflow:auto;margin:.3em 0 .7em 0"><table style="border-collapse:separate;border-spacing:0;width:100%;background:var(--card);border:1px solid var(--brd);border-radius:11px">${cap}${thead}<tbody>${tbody}</tbody></table></div>`;
  }
  function copyCSVFromCard(btn){
    const card = btn.closest('.tool-card');
    const csv = card?.dataset?.csv || '';
    if (!csv) return;
    navigator.clipboard.writeText(csv).then(()=>{
      btn.textContent='Copied!';
      setTimeout(()=>btn.textContent='Copy CSV',900);
    });
  }
  function downloadCSVFromCard(btn){
    const card = btn.closest('.tool-card');
    const csv = card?.dataset?.csv || '';
    const name = card?.dataset?.csvFilename || 'table.csv';
    if (!csv) return;
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  const messageInput=document.getElementById('messageInput');
  const sendButton=document.getElementById('sendButton');
  messageInput.addEventListener('keydown',e=>{
    if(e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      sendMessage();
    }
  });
  messageInput.addEventListener('input',function(){
    this.style.height='auto';
    this.style.height=Math.min(this.scrollHeight,150)+'px';
    const qa = document.getElementById('quickAsks');
    if (qa && messageInput.value.trim().length) qa.style.display = 'none';
  });

  function addUser(text){
    const el=document.createElement('div'); el.className='message user';
    el.innerHTML=`<div class="message-avatar" title="You">üë§</div>
      <div class="message-content">
        <div class="timestamp">${nowStamp()}</div>
        <div class="message-bubble"></div>
      </div>`;
    el.querySelector('.message-bubble').textContent = text;
    document.getElementById('messagesContainer').appendChild(el);
    scrollEnd();
  }

  function kickOffStream(){
    orchestratorDone=false;
    startStreaming();
    currentAssistantMessage=null; currentToolCards.clear();
    orchestratorBuf=''; toolBuffers.clear(); toolCount=0;
    pendingUI.clear();
    suppressOrchStream=false;
    toolStartTimes.clear(); toolElapsed.clear();
  }

  function sendMessage(){
    const txt=messageInput.value.trim();
    if(!txt || !ws || ws.readyState!==WebSocket.OPEN) return;
    addUser(txt);
    ws.send(JSON.stringify({user_input:txt, session_id: activeSessionId}));
    messageInput.value=''; messageInput.style.height='auto';
    kickOffStream();
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = 'none';
  }

  function askPreset(text){
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    addUser(text);
    ws.send(JSON.stringify({ user_input: text, session_id: activeSessionId }));
    messageInput.value=''; messageInput.style.height='auto';
    kickOffStream();
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = 'none';
  }
  function showQuickAsks(){
    const qa = document.getElementById('quickAsks');
    if (qa) qa.style.display = '';
  }

  function initTheme(){
    try{
      const saved = localStorage.getItem('biochirp_theme');
      if (saved) document.documentElement.setAttribute('data-theme', saved);
    }catch{}
    document.getElementById('themeToggle')?.addEventListener('click', ()=>{
      const cur = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = (cur==='dark') ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      try{ localStorage.setItem('biochirp_theme', next); }catch{}
    });
  }

  /* =========================
     SHARE: static, readable snapshot
     ========================= */

  function absolutizeLinks(rootEl, base) {
    const aTags = rootEl.querySelectorAll('a[href]');
    for (const a of aTags) {
      try { a.href = new URL(a.getAttribute('href'), base).toString(); } catch {}
    }
    const imgTags = rootEl.querySelectorAll('img[src]');
    for (const img of imgTags) {
      const src = img.getAttribute('src');
      if (src && !/^data:|^https?:/i.test(src)) {
        try { img.src = new URL(src, base).toString(); } catch {}
      }
    }
  }

  async function inlineImagesToDataURL(container) {
    const imgs = Array.from(container.querySelectorAll('img[src]'));
    for (const img of imgs) {
      const src = img.getAttribute('src') || '';
      if (!src || /^data:/i.test(src)) continue;
      try {
        const res = await fetch(src, { mode: 'cors' });
        if (!res.ok) continue;
        const blob = await res.blob();
        const reader = new FileReader();
        await new Promise((resolve, reject) => {
          reader.onload = () => resolve();
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
        img.setAttribute('src', reader.result);
      } catch { /* leave as absolute URL */ }
    }
  }

  function collectHeadForShare() {
    const out = document.createElement('head');

    const title = document.createElement('title');
    title.textContent = document.title || 'BioChirp ‚Äî Shared Chat';
    out.appendChild(title);

    const meta1 = document.createElement('meta');
    meta1.setAttribute('charset','utf-8');
    out.appendChild(meta1);
    const meta2 = document.createElement('meta');
    meta2.setAttribute('name','viewport');
    meta2.setAttribute('content','width=device-width,initial-scale=1');
    out.appendChild(meta2);

    document.querySelectorAll('link[rel="stylesheet"]').forEach(link=>{
      out.appendChild(link.cloneNode(true));
    });

    const styleBundle = document.createElement('style');
    let cssText = '';
    document.querySelectorAll('style').forEach(st => { cssText += st.textContent + '\n'; });
    styleBundle.textContent = cssText;
    out.appendChild(styleBundle);

    return out;
  }

  async function buildShareHTML() {
    // persist preview rows on live cards so clone sees them
    const liveApp = document.querySelector('.app');
    if (liveApp) {
      liveApp.querySelectorAll('.tool-card.table-card').forEach(card => {
        if (card._preview && Array.isArray(card._preview.rows)) {
          try {
            card.setAttribute('data-preview-rows', JSON.stringify(card._preview.rows));
          } catch {}
        }
      });
    }

    const htmlEl = document.documentElement.cloneNode(false);

    const lang = document.documentElement.getAttribute('lang') || 'en';
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    htmlEl.setAttribute('lang', lang);
    htmlEl.setAttribute('data-theme', theme);

    const head = collectHeadForShare();
    htmlEl.appendChild(head);

    const body = document.createElement('body');
    const app = document.querySelector('.app');
    const appClone = app ? app.cloneNode(true) : document.body.cloneNode(true);

    // Collapse cards initially
    appClone.querySelectorAll('.tool-card').forEach(card => {
      card.classList.remove('expanded','show-output');
    });

    // Remove inline onclick from headers (we‚Äôll rewire in snapshot script)
    appClone.querySelectorAll('.tool-card .tool-header').forEach(h => {
      h.removeAttribute('onclick');
    });

    // Turn each .tool-card into <details><summary>, copying data-*
    appClone.querySelectorAll('.tool-card').forEach(card => {
      const header = card.querySelector('.tool-header');
      const bodyEl = card.querySelector('.tool-body');
      if (!header || !bodyEl) return;

      const details = document.createElement('details');
      details.className = card.className;

      // copy data-* attributes so preview + filenames survive
      Array.from(card.attributes).forEach(attr => {
        if (attr.name.startsWith('data-')) {
          details.setAttribute(attr.name, attr.value);
        }
      });

      if (card.classList.contains('expanded')) {
        details.setAttribute('open', '');
      }

      const summary = document.createElement('summary');
      summary.className = header.className;
      summary.innerHTML = header.innerHTML;

      details.appendChild(summary);
      details.appendChild(bodyEl);

      card.replaceWith(details);
    });

    // Disable only chat controls (header buttons + input)
    appClone.querySelectorAll('button').forEach(b => {
      if (b.closest('.chat-header') || b.closest('.input-area')) {
        b.disabled = true;
      }
    });

    absolutizeLinks(appClone, window.location.origin);
    await inlineImagesToDataURL(appClone);

    const banner = document.createElement('div');
    banner.style.cssText =
      "position:sticky;top:0;z-index:50;margin:0;padding:8px 12px;" +
      "text-align:center;font-size:12px;border-bottom:1px solid var(--brd);" +
      "background:color-mix(in oklab, var(--bg1) 92%, transparent)";
    banner.textContent = "Read-only snapshot ‚Ä¢ Generated by BioChirp Share";

    body.appendChild(banner);
    body.appendChild(appClone);

    const behaviorScript = document.createElement('script');
    behaviorScript.textContent = `
      (function(){
        function toggleCard(header){
          var card = header && header.closest ? header.closest('.tool-card') : null;
          if (!card) return;
          if (card.tagName && card.tagName.toLowerCase() === 'details') {
            if (card.hasAttribute('open')) {
              card.removeAttribute('open');
            } else {
              card.setAttribute('open','');
            }
          }
          card.classList.toggle('expanded');
        }
        window.toggleCard = toggleCard;

        document.addEventListener('click', function(ev){
          var header = ev.target.closest && ev.target.closest('.tool-card .tool-header');
          if (!header) return;
          var card = header.closest('.tool-card');
          if (!card) return;
          if (card.tagName && card.tagName.toLowerCase() === 'details') {
            setTimeout(function(){
              if (card.hasAttribute('open')) {
                card.classList.add('expanded');
              } else {
                card.classList.remove('expanded');
              }
            }, 0);
          } else {
            ev.preventDefault();
            toggleCard(header);
          }
        });

        function tableHtml(rows, caption){
          if (!rows || !rows.length) {
            return '<div style="color:var(--mut);font-style:italic;padding:6px 2px">[Empty Table]</div>';
          }
          var cols = Object.keys(rows[0]);
          var thead =
            '<thead><tr>' +
            cols.map(function(k){
              return '<th style="position:sticky;top:0;background:var(--bg3);color:var(--txt);padding:10px 12px;border-bottom:1px solid var(--brd);text-align:left;font-size:13px">' +
                     k.replace(/_/g,' ') + '</th>';
            }).join('') +
            '</tr></thead>';
          var tbody = rows.map(function(r){
            return '<tr>' + cols.map(function(c){
              var v = r[c] == null ? '' : String(r[c]);
              var safe = v.replace(/"/g,'&quot;');
              return '<td style="padding:9px 12px;border-bottom:1px solid var(--brd)">' +
                       '<div style="max-width:600px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + safe + '">' +
                         safe +
                       '</div>' +
                     '</td>';
            }).join('') + '</tr>';
          }).join('');
          var cap = caption
            ? '<caption style="text-align:left;color:var(--accent);padding:8px 6px 6px;font-weight:800">üîé ' + caption + '</caption>'
            : '';
          return '<div style="width:100%;overflow:auto;margin:.3em 0 .7em 0">' +
                   '<table style="border-collapse:separate;border-spacing:0;width:100%;background:var(--card);border:1px solid var(--brd);border-radius:11px">' +
                     cap + thead + '<tbody>' + tbody + '</tbody>' +
                   '</table>' +
                 '</div>';
        }

        function csvEscape(val){
          var s = val == null ? '' : String(val);
          return /[",\\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
        }

        function buildCSV(columns, rows){
          if (!columns || !columns.length) return '';
          var head = columns.join(',');
          var body = rows.map(function(r){
            return columns.map(function(c){ return csvEscape(r[c]); }).join(',');
          }).join('\\n');
          return head + '\\n' + body;
        }

        function collectTableData(table){
          if (!table) return {columns:[], rows:[]};
          var cols = [];
          var ths = table.querySelectorAll('thead th');
          for (var i=0;i<ths.length;i++){
            cols.push((ths[i].textContent || ths[i].innerText || '').trim());
          }
          var rows = [];
          var trs = table.querySelectorAll('tbody tr');
          for (var r=0;r<trs.length;r++){
            var tds = trs[r].querySelectorAll('td');
            var obj = {};
            for (var c=0;c<cols.length;c++){
              var cell = tds[c];
              obj[cols[c]] = cell ? (cell.textContent || cell.innerText || '').trim() : '';
            }
            rows.push(obj);
          }
          return {columns:cols, rows:rows};
        }

        function bootstrapTableCard(card){
          var previewEl = card.querySelector('.table-preview');
          var labelEl   = card.querySelector('.pager-label');
          var prevBtn   = card.querySelector('.pager-prev');
          var nextBtn   = card.querySelector('.pager-next');
          if (!previewEl || !labelEl || !prevBtn || !nextBtn) return;

          var rows = [];
          var json = card.getAttribute('data-preview-rows');
          if (json) {
            try { rows = JSON.parse(json); } catch(e){}
          }
          if (!rows || !rows.length) {
            var table = previewEl.querySelector('table');
            var parsed = collectTableData(table);
            rows = parsed.rows || [];
          }
          if (!rows || !rows.length) return;

          var state = {
            page: 1,
            rpp: 5,
            rows: rows,
            columns: Object.keys(rows[0])
          };

          function render(){
            var total = state.rows.length;
            var totalPages = Math.max(1, Math.ceil(total / state.rpp));
            if (state.page > totalPages) state.page = totalPages;
            var start = (state.page - 1) * state.rpp;
            var slice = state.rows.slice(start, start + state.rpp);
            labelEl.textContent = 'Page ' + state.page + ' of ' + totalPages;
            prevBtn.disabled = state.page <= 1;
            nextBtn.disabled = state.page >= totalPages;
            previewEl.innerHTML = tableHtml(
              slice,
              'Preview ¬∑ rows ' + (start+1) + '-' + Math.min(start + slice.length, total) + ' of ~' + total
            );
          }

          prevBtn.addEventListener('click', function(){
            if (state.page > 1) {
              state.page -= 1;
              render();
            }
          });

          nextBtn.addEventListener('click', function(){
            var totalPages = Math.max(1, Math.ceil(state.rows.length / state.rpp));
            if (state.page < totalPages) {
              state.page += 1;
              render();
            }
          });

          card._snapshotTableState = state;
          render();
        }

        function buildCsvForCard(card){
          if (!card) return '';
          var state = card._snapshotTableState;
          if (state && state.rows && state.rows.length){
            var cols = state.columns || Object.keys(state.rows[0]);
            return buildCSV(cols, state.rows);
          }
          var table =
            card.querySelector('.tool-output table') ||
            card.querySelector('.table-preview table') ||
            card.querySelector('table');
          var parsed = collectTableData(table);
          if (!parsed.rows || !parsed.rows.length) return '';
          return buildCSV(parsed.columns, parsed.rows);
        }

        window.copyCSVFromCard = function(btn){
          var card = btn && btn.closest ? btn.closest('.tool-card') : null;
          if (!card) return;
          var csv = buildCsvForCard(card);
          if (!csv) return;
          navigator.clipboard.writeText(csv).then(function(){
            btn.textContent = 'Copied!';
            setTimeout(function(){ btn.textContent = 'Copy CSV'; }, 900);
          }).catch(function(){});
        };

        window.downloadCSVFromCard = function(btn){
          var card = btn && btn.closest ? btn.closest('.tool-card') : null;
          if (!card) return;
          var csv = buildCsvForCard(card);
          if (!csv) return;
          var name = card.getAttribute('data-csvFilename') || 'table.csv';
          var blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = name;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(a.href);
          a.remove();
        };

        document.addEventListener('DOMContentLoaded', function(){
          var cards = document.querySelectorAll('.tool-card.table-card');
          for (var i=0;i<cards.length;i++){
            bootstrapTableCard(cards[i]);
          }
        });
      })();
    `;
    body.appendChild(behaviorScript);

    htmlEl.appendChild(body);
    return '<!DOCTYPE html>\\n' + htmlEl.outerHTML;
  }

  function showShareToast(url, err) {
    const old = document.getElementById('shareToast'); if (old) old.remove();
    const t = document.createElement('div');
    t.id = 'shareToast';
    t.className = 'toast';
    if (!err) {
      t.innerHTML = `
        <h4>Share link created</h4>
        <div class="row">
          <input id="shareLinkInput" value="${url}" readonly />
          <button class="reconnect" id="copyShareBtn">Copy</button>
        </div>
        <div class="btns">
          <a class="reconnect" target="_blank" rel="noopener" href="${url}">Open</a>
          <button class="reconnect" id="closeShareBtn">Close</button>
        </div>`;
    } else {
      t.innerHTML = `
        <h4 style="color:var(--err)">Couldn‚Äôt create share link</h4>
        <div style="font-size:13px;color:var(--mut)">${err}</div>
        <div class="btns">
          <button class="reconnect" id="closeShareBtn">Close</button>
        </div>`;
    }
    document.body.appendChild(t);
    document.getElementById('closeShareBtn')?.addEventListener('click', ()=> t.remove());
    document.getElementById('copyShareBtn')?.addEventListener('click', ()=>{
      const inp = document.getElementById('shareLinkInput');
      if (!inp) return;
      inp.select(); inp.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(inp.value).then(()=>{
        const btn = document.getElementById('copyShareBtn');
        if (!btn) return;
        btn.textContent = 'Copied!';
        setTimeout(()=>btn.textContent='Copy',900);
      });
    });
  }

  async function handleShareClick() {
    try {
      const html = await buildShareHTML();
      const res = await fetch('/share', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({
          html,
          title: 'BioChirp Chat Snapshot',
          unsafe: true
        })
      });

      let bodyText = await res.text();
      let data = null;
      try { data = JSON.parse(bodyText); } catch {}
      if (!res.ok) {
        const detail = (data && (data.detail || data.error)) || bodyText || ('HTTP ' + res.status);
        showShareToast('', detail);
        return;
      }
      const rawUrl = (data && data.url) ? data.url : '';
      if (!rawUrl) {
        showShareToast('', 'No URL in server response');
        return;
      }
      const url = new URL(rawUrl, window.location.origin).toString();
      showShareToast(url);
    } catch (e) {
      showShareToast('', (e && e.message) || 'Unknown error');
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('shareBtn')?.addEventListener('click', handleShareClick);
  });
</script>
</body>
</html>
